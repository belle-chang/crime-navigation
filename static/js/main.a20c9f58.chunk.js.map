{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapboxgl","accessToken","App","mapContainerRef","useRef","useState","lng","setLng","lat","setLat","zoom","setZoom","useEffect","min_intersections","route","map","Map","container","current","style","center","obstacle","turf","fw","units","bbox","polygon","counter","num_intersections","Infinity","on","cities","data","bos","i","length","addSource","type","cluster","clusterMaxZoom","clusterRadius","addLayer","id","source","filter","paint","layout","dictionary","lng_lat_zoom","key","hasOwnProperty","console","log","link","document","createElement","href","className","textContent","getElementById","appendChild","getElementsByClassName","onclick","e","flyTo","addControl","NavigationControl","directions","MapboxDirections","unit","profile","geometries","alternatives","walkway_bias","alley_bias","steps","controls","instructions","isEmpty","obj","Object","keys","setLayoutProperty","innerHTML","visibility","addDirections","removeRoutes","legs","str","distance","toFixed","duration","maneuver","instruction","miles","dist","feet","tempo","getOrigin","tempd","getDestination","notice","routes","getSource","setData","forEach","routeLine","polyline","toGeoJSON","geometry","intersects","features","setPaintProperty","randomWaypoint","setWaypoint","coordinates","getCenter","getZoom","remove","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a20c9f58.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport './App.css';\nimport mapboxgl from 'mapbox-gl';\n// import 'mapbox-gl/dist/mapbox-gl.css';\nimport MapboxDirections from '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions'\nimport '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'\nimport * as turf from '@turf/turf';\nimport polyline from '@mapbox/polyline'\nimport bos from './bos_clean_final.json'\nimport fw from './fw_clean_final.json'\n\nmapboxgl.accessToken =\n    'pk.eyJ1IjoiYW5hYmVsbGVjaGFuZyIsImEiOiJja20xZmVxNGYwMTRpMnJtemJ0M3podzFzIn0.punpaEzFpzG4kmbcpdtwUQ'\n\nconst App = () => {\n    // playign with here api\n    {\n    // const apiUrl = 'https://route.ls.hereapi.com/routing/7.2/calculateroute.json?apiKey=dQsyJbZZS_IvjJSlSFFxt1tadvGuxoOzkxEn5wGTP80&waypoint0=geo!52.5184443440238,13.383906494396967&waypoint1=geo!52.51435421904425,13.396947378094524&mode=fastest;car;traffic:disabled&avoidareas=52.517100760,13.3905424488;52.5169701849,13.391808451!52.51623131288022,13.389888672738778;52.51335487996589,13.395274548440511!52.52006148651319,13.385160024545286;52.517760038213815,13.389707563495335';\n    // fetch(apiUrl)\n    //   .then((response) => response.json())\n    //   .then((data) => console.log('This is your data', data));\n    }\n      \n    const mapContainerRef = useRef(null);\n    // boston\n    // const [lng, setLng] = useState(-71.0799);\n    // const [lat, setLat] = useState(42.3083);\n    // const [zoom, setZoom] = useState(13.59);\n\n    const [lng, setLng] = useState(-96.2485);\n    const [lat, setLat] = useState(38.5370);\n    const [zoom, setZoom] = useState(4.16);\n    // Initialize map when component mounts\n    useEffect(() => {\n        // crate new map\n        const map = new mapboxgl.Map({\n        container: mapContainerRef.current,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        //   style: 'mapbox://styles/anabellechang/ckm11howb889h17qf87wj3ld6',\n        center: [lng, lat],\n        zoom: zoom\n        });\n\n        let obstacle = turf.buffer(fw, 7, { units: \"meters\" });\n        let bbox = [0, 0, 0, 0];\n        let polygon = turf.bboxPolygon(bbox);\n        let counter = 0;\n        let maxAttempts = 50;\n        let min_intersections;\n        let num_intersections = Infinity;\n        let route;\n\n        map.on('load', function() {\n            let cities = ['bos', 'fw'];\n            let data = [bos, fw]\n            // let cities_geo = ['https://raw.githubusercontent.com/belle-chang/crime-navigation/master/data/bos_clean_final.json', 'https://github.com/belle-chang/crime-navigation/blob/master/data/fw_clean_final.json'];\n\n            for (let i = 0; i < cities.length; i++) {\n                map.addSource(\"crime-\" + cities[i], {\n                    type: 'geojson',\n                    // data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'\n                    data: data[i],\n                    cluster: true,\n                    clusterMaxZoom: 14,\n                    clusterRadius: 50\n                });\n\n                map.addLayer({\n                    id: \"clusters-\" + cities[i],\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    type: \"circle\",\n                    filter: ['has', 'point_count'],\n                    // paint properties\n                    paint: {\n                    //   \"circle-opacity\": 0.75,\n                    //   \"circle-stroke-width\": 1,\n                    //   \"circle-radius\": 4,\n                    //   \"circle-color\": \"#FFEB3B\"\n                        'circle-color': [\n                            'step',\n                            ['get', 'point_count'],\n                            '#ffb6ab',\n                            20,\n                            '#f5735f',\n                            50,\n                            '#b83e2c'\n                            ],\n                            'circle-radius': [\n                            'step',\n                            ['get', 'point_count'],\n                            20,\n                            20,\n                            30,\n                            50,\n                            40\n                        ]\n                    },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'cluster-count-' + cities[i],\n                    // id: 'clusters',\n                    type: 'symbol',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['has', 'point_count'],\n                    layout: {\n                        'text-field': '{point_count_abbreviated}',\n                        'text-font': ['Arial Unicode MS Bold'],\n                        'text-size': 12,\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'unclustered-point-' + cities[i],\n                    // id: 'clusters',\n                    type: 'circle',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['!', ['has', 'point_count']],\n                    paint: {\n                        'circle-color': '#fc0b03',\n                        // 'circle-color': '#ffffff',\n                        'circle-radius': 5,\n                        'circle-stroke-width': 2,\n                        'circle-stroke-color': '#fff'\n                        },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                        }\n                });\n                // console.log(map.getStyle().layers)\n            }\n            // testing routing api\n            {\n            \n            // map.addSource(\"obstacles\", {\n            //     type: 'geojson',\n            //     data: obstacle\n            // })\n            // map.addLayer({\n            //     id: 'obstacles',\n            //     type: 'fill',\n            //     source: \"obstacles\",\n            //     paint: {\n            //         'fill-color': '#f03b20',\n            //         // 'circle-radius': 5,\n            //         // 'circle-stroke-width': 1,\n            //         'fill-opacity': 0.5,\n            //         'fill-outline-color': '#f03b20'\n            //     }\n            // });\n                 \n            map.addSource('theRoute', {\n                type: 'geojson',\n                data: {\n                    type: 'Feature'\n                }\n            });\n                 \n            map.addLayer({\n                id: 'theRoute',\n                type: 'line',\n                source: 'theRoute',\n                layout: {\n                'line-join': 'round',\n                'line-cap': 'round'\n                },\n                paint: {\n                'line-color': '#4881c5',\n                'line-opacity': 0.75,\n                'line-width': 10,\n                'line-blur': 0.5,\n                }\n            });\n                 \n            // Source and layer for the bounding box\n            map.addSource('theBox', {\n                type: 'geojson',\n                data: {\n                type: 'Feature'\n                }\n                });\n                map.addLayer({\n                id: 'theBox',\n                type: 'fill',\n                source: 'theBox',\n                layout: {},\n                paint: {\n                'fill-color': '#FFC300',\n                'fill-opacity': 0.5,\n                'fill-outline-color': '#FFC300'\n                }\n            });\n            }\n        });\n\n        let dictionary = {\n            \"Boston\": ['clusters-bos', 'cluster-count-bos', 'unclustered-point-bos'],\n            \"Fort Worth\": ['clusters-fw', 'cluster-count-fw', 'unclustered-point-fw']\n        }\n        let lng_lat_zoom = {\n            \"Boston\": {\n                center: [-71.0799, 42.3083],\n                zoom: 11.27\n            },\n            \"Fort Worth\": {\n                center: [-97.3444, 32.8168],\n                zoom: 9.73\n            }\n        }\n        let data = {\n            \"Boston\": bos,\n            \"Fort Worth\": fw\n        }\n\n        for (let key in dictionary) {\n            // check if the property/key is defined in the object itself, not in parent\n            if (dictionary.hasOwnProperty(key)) {           \n                console.log(key, dictionary[key]);\n                let link = document.createElement('a');\n                link.id = key;\n                link.href = '#';\n                link.className = 'active city_menu';\n                link.textContent = key;\n            let layers = document.getElementById('menu');\n            layers.appendChild(link);\n            }\n        }\n        // fly to city, set obstacle \n        let cities = document.getElementsByClassName(\"city_menu\");\n        for (let i = 0; i < cities.length; i++) {\n            cities[i].onclick = function(e) {\n                map.flyTo(lng_lat_zoom[cities[i].id])\n                obstacle = turf.buffer(data[cities[i].id], 7, { units: \"meters\" });\n            }\n            // map.getSource('obstacles').setData(obstacle);\n        }\n\n\n        // Add navigation control (the +/- zoom buttons) the top right of the canvas\n        map.addControl(new mapboxgl.NavigationControl());\n        // map.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n        const directions = new MapboxDirections({\n            accessToken: mapboxgl.accessToken,\n            unit: 'imperial',\n            profile: 'mapbox/walking',\n            geometries: 'geojson',\n            alternatives: false,\n            flyTo: false,\n            walkway_bias: .75,\n            alley_bias: -.75,\n            steps: true,\n            controls: { instructions: false },\n            flyTo: false\n        });\n\n        // Integrates directions control with map\n        map.addControl(directions, 'top-left');\n\n        let isEmpty = function(obj){\n            return Object.keys(obj).length === 0;\n        }\n\n        directions.on('clear', function(e) {\n            counter = 0;\n            num_intersections = Infinity;\n            // map.setLayoutProperty('theRoute', 'visibility', 'none');\n            map.setLayoutProperty('theBox', 'visibility', 'none');\n            let instructions = document.getElementById('instructions')\n            instructions.innerHTML = \"\"\n            instructions.style.visibility = \"hidden\"\n        });\n\n        let addDirections = function(route) {\n            directions.removeRoutes();\n            let notice = document.getElementById(\"notice\");\n            notice.style.visibility = \"hidden\"\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \"\n            let instructions = document.getElementById('instructions');\n            instructions.style.visibility = \"visible\"\n            let steps = route.legs[0].steps;\n            console.log(steps)\n            let total_dist = (route.distance / 1609.344).toFixed(2);\n            let duration = (route.duration / 60).toFixed(0);\n            let str = \"<tr> \"+ \"<td><b>\" + total_dist + \"mi\" + \"</b></td>\" + \"<td>\" + duration + \"min\" + \"</td>\" + \"</tr>\"\n            instructions.innerHTML += str;\n            for (var i = 0; i < steps.length; i++) {\n                console.log(steps[i].maneuver.instruction);\n                \n                let miles = (steps[i].distance / 1609.344).toFixed(2);\n                let dist = miles;\n                let unit = \"mi\";\n                let feet = (steps[i].distance / 0.3048).toFixed(0);\n                if (miles < 0.15) {\n                    dist = feet;\n                    unit = \"ft\"\n                }\n                // let str = \"<li> \"+steps[i].maneuver.instruction + \"--\" + dist + unit + \"</li>\"\n                let str = \"<tr> \"+ \"<td>\" + dist + unit + \"</td>\" + \"<td>\" + steps[i].maneuver.instruction + \"</td>\" + \"</tr>\"\n                instructions.innerHTML += str;\n            }\n        }\n\n        directions.on('route', function (e) {\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) || isEmpty(tempd)) {\n                directions.removeRoutes();\n                return;\n            }\n            let notice = document.getElementById(\"notice\");\n            if (notice.style.visibility != \"visible\") notice.style.visibility = \"visible\";\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \" + counter + \".\"\n\n            let instructions = document.getElementById('instructions');\n            if (instructions.style.visibility != \"hidden\") instructions.style.visibility = \"hidden\";\n            \n            let routes = e.route;\n             \n            // Hide the route and box by setting the opacity to zero\n            // map.setLayoutProperty('theRoute', 'visibility', 'none');\n            // map.setLayoutProperty('theBox', 'visibility', 'none');\n             \n            if (counter >= maxAttempts) {\n                console.log(min_intersections)\n                e.route = route;\n                console.log(e.route)\n                map.getSource('theRoute').setData(min_intersections);\n                addDirections(e.route);\n            } \n            else {\n                // Make each route visible\n                routes.forEach((e) => {\n\n                    console.log(counter);\n                    // Make each route visible\n                    map.setLayoutProperty('theRoute', 'visibility', 'visible');\n                    map.setLayoutProperty('theBox', 'visibility', 'visible');\n                    \n                    // Get GeoJson LineString feature of route\n                    let routeLine = polyline.toGeoJSON(e.geometry);\n                    // console.log(obstacle)\n                    \n                    let intersects = turf.lineIntersect(obstacle, routeLine);\n\n                    // get route with minimum intersections\n                    if (intersects.features.length < num_intersections) {\n                        num_intersections = intersects.features.length;\n                        min_intersections = routeLine;\n                        route = e;\n                    }\n                    \n                    // Create a bounding box around this route\n                    // The app will find a random point in the new bbox\n                    bbox = turf.bbox(routeLine);\n                    polygon = turf.bboxPolygon(bbox);\n                    // let points_within = turf.pointsWithinPolygon(obstacle, polygon);\n                    // console.log(points_within)\n                    \n                    // Update the data for the route\n                    // This will update the route line on the map\n                    map.getSource('theRoute').setData(routeLine);\n                    // Update the box\n                    map.getSource('theBox').setData(polygon);\n                    \n                    let clear = turf.booleanDisjoint(obstacle, routeLine);\n                    \n                    if (clear == true) {\n                        // Hide the box\n                        map.setLayoutProperty('theBox', 'visibility', 'none');\n                        map.setPaintProperty('theRoute', 'line-color', '#74c476');\n                        // Reset the counter, min intersections\n                        route = e;\n                        counter = 0;\n                        num_intersections = Infinity;\n                        addDirections(route);\n                    } else {\n                    // Collision occurred, so increment the counter\n                        counter = counter + 1;\n                        // As the attempts increase, expand the search area\n                        // by a factor of the attempt count\n                        polygon = turf.transformScale(polygon, counter * 0.025);\n                        bbox = turf.bbox(polygon);\n                        map.setPaintProperty('theRoute', 'line-color', '#4881c5');\n                        \n                        // Add a randomly selected waypoint to get a new route from the Directions API\n                        let randomWaypoint = turf.randomPoint(1, { bbox: bbox });\n                        directions.setWaypoint(\n                            0,\n                            randomWaypoint['features'][0].geometry.coordinates\n                        );\n                    }\n                });\n            }\n        });\n\n        map.on('move', function() {\n            // shitty workaround\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) && isEmpty(tempd)) {\n                map.setLayoutProperty('theRoute', 'visibility', 'none');\n            }\n            setLng(map.getCenter().lng.toFixed(4));\n            setLat(map.getCenter().lat.toFixed(4));\n            setZoom(map.getZoom().toFixed(2));\n        });\n\n        // map.on('moveend', function() {\n        //     let lng = map.getCenter().lng.toFixed(4)\n        //     console.log(lng_city[lng])\n        //     if (lng_city[lng]) {\n        //         obstacle = turf.buffer(lng_city[lng], 7, { units: \"meters\" });\n        //         // map.getSource('obstacles').setData(obstacle);\n        //     }\n        // })\n\n        \n\n        // Clean up on unmount\n        return () => map.remove();\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return (\n        <div>\n            <nav id=\"menu\">\n                <a id=\"title\" href=\"#\">\n                    Available Cities\n                </a>\n            </nav>\n            \n            <div id=\"loader\">\n                <br/>\n                <h1>Welcome to Crime Navigation!</h1>\n                This is an application created to help you navigate around crime-ridden areas in dense urban areas. Current featured cities include Boston and Fort Worth.\n                <br/>\n                <br/>\n                Click on a city in the lower left menu to get started!\n                <a id=\"x\">x</a>\n            </div>\n        <div id=\"notice\">\n           <b>Your custom route is being calculated!</b> \n           <br/>\n           <div id=\"route_num\">Running route </div>\n        </div>\n\n        <table id=\"instructions\" >\n        \n        </table>\n        {/* <div className='sidebarStyle'>\n            <div>\n            Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n            </div>\n        </div> */}\n        <div className='map-container' ref={mapContainerRef} />\n        \n        </div>\n    );\n};\n\nexport default App;\n\n// class App extends React.Component {\n\n//   componentDidMount() {\n\n//     // Creates new map instance\n//     const map = new mapboxgl.Map({\n//       container: this.mapWrapper,\n//       style: 'mapbox://styles/mapbox/streets-v10',\n//       center: [-73.985664, 40.748514],\n//       zoom: 12\n//     });\n\n//     // Creates new directions control instance\n//     const directions = new MapboxDirections({\n//       accessToken: mapboxgl.accessToken,\n//       unit: 'metric',\n//       profile: 'mapbox/driving',\n//     });\n\n//     // Integrates directions control with map\n//     map.addControl(directions, 'top-left');\n//   }\n\n//   render() {\n//     return (\n//       // Populates map by referencing map's container property\n//       <div ref={el => (this.mapWrapper = el)} className=\"mapWrapper\" />\n//     );\n//   }\n// }\n\n// export default App;\n\n                // turns off cities\n                // link.onclick = function (e) {\n                //     for (let index in dictionary[key]) {\n                //         let clickedLayer = dictionary[key][index];\n                //         e.preventDefault();\n                //         e.stopPropagation();\n                    \n                //         let visibility = map.getLayoutProperty(clickedLayer, 'visibility');\n                    \n                //         if (visibility === 'visible') {\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'none');\n                //             this.className = '';\n                //         } else {\n                //             this.className = 'active';\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'visible');\n                //         }\n                //     }\n                // };","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}