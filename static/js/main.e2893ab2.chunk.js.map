{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapboxgl","accessToken","App","mapContainerRef","useRef","useState","lng","setLng","lat","setLat","zoom","setZoom","useEffect","min_intersections","current_city","route","map","Map","container","current","style","center","obstacle","turf","fw","units","bbox","polygon","counter","num_intersections","Infinity","distance","on","addSource","type","data","allcities","cluster","clusterMaxZoom","clusterRadius","addLayer","id","source","filter","paint","layout","cities","lng_lat_zoom","bos","chi","sf","once","i","length","console","log","link","document","createElement","href","className","textContent","getElementById","appendChild","menu_cities","getElementsByClassName","onclick","e","flyTo","addControl","NavigationControl","directions","MapboxDirections","unit","profile","geometries","alternatives","walkway_bias","alley_bias","steps","controls","instructions","isEmpty","obj","Object","keys","hide_element","el_name","visibility","setLayoutProperty","innerHTML","addDirections","removeRoutes","legs","str","toFixed","duration","miles","dist","feet","maneuver","instruction","window","alert","tempo","getOrigin","tempd","getDestination","notice","routes","getSource","setData","forEach","routeLine","polyline","toGeoJSON","geometry","points_within","intersects","features","randomWaypoint","setWaypoint","coordinates","getCenter","getZoom","close_loader","parentElement","remove","size","fill","ref","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e2893ab2.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport './App.css';\nimport mapboxgl from 'mapbox-gl';\n// import 'mapbox-gl/dist/mapbox-gl.css';\nimport MapboxDirections from '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions'\nimport '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'\nimport * as turf from '@turf/turf';\nimport polyline from '@mapbox/polyline'\nimport bos from './bos_nodupes.json'\nimport fw from './fw_nodupes.json'\nimport chi from './chi_nodupes.json'\nimport sf from './sf_nodupes.json'\nimport allcities from './allcities_nodupes.json'\nimport {XIcon, QuestionIcon} from '@primer/octicons-react'\n\nmapboxgl.accessToken =\n    'pk.eyJ1IjoiYW5hYmVsbGVjaGFuZyIsImEiOiJja20xZmVxNGYwMTRpMnJtemJ0M3podzFzIn0.punpaEzFpzG4kmbcpdtwUQ'\n\nconst App = () => {\n    // playign with here api\n    {\n    // const apiUrl = 'https://route.ls.hereapi.com/routing/7.2/calculateroute.json?apiKey=dQsyJbZZS_IvjJSlSFFxt1tadvGuxoOzkxEn5wGTP80&waypoint0=geo!52.5184443440238,13.383906494396967&waypoint1=geo!52.51435421904425,13.396947378094524&mode=fastest;car;traffic:disabled&avoidareas=52.517100760,13.3905424488;52.5169701849,13.391808451!52.51623131288022,13.389888672738778;52.51335487996589,13.395274548440511!52.52006148651319,13.385160024545286;52.517760038213815,13.389707563495335';\n    // fetch(apiUrl)\n    //   .then((response) => response.json())\n    //   .then((data) => console.log('This is your data', data));\n    }\n      \n    const mapContainerRef = useRef(null);\n    // boston\n    // const [lng, setLng] = useState(-71.0799);\n    // const [lat, setLat] = useState(42.3083);\n    // const [zoom, setZoom] = useState(13.59);\n\n    const [lng, setLng] = useState(-96.2485);\n    const [lat, setLat] = useState(38.5370);\n    const [zoom, setZoom] = useState(4.16);\n    // Initialize map when component mounts\n    useEffect(() => {\n        // crate new map\n        const map = new mapboxgl.Map({\n        container: mapContainerRef.current,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        //   style: 'mapbox://styles/anabellechang/ckm11howb889h17qf87wj3ld6',\n        center: [lng, lat],\n        zoom: zoom\n        });\n\n        let obstacle = turf.buffer(fw, 7, { units: \"meters\" });\n        let bbox = [0, 0, 0, 0];\n        let polygon = turf.bboxPolygon(bbox);\n        let counter = 0;\n        let maxAttempts = 50;\n        let min_intersections;\n        let num_intersections = Infinity;\n        let distance = Infinity;\n        let current_city;\n        let route;\n\n        map.on('load', function() {\n            map.addSource(\"crime\", {\n                type: 'geojson',\n                // data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'\n                data: allcities,\n                cluster: true,\n                clusterMaxZoom: 14,\n                clusterRadius: 50\n            });\n\n            map.addLayer({\n                id: \"clusters\",\n                source: \"crime\", // this should be the id of the source\n                type: \"circle\",\n                filter: ['has', 'point_count'],\n                // paint properties\n                paint: {\n                    \"circle-opacity\": 0.75,\n                //   \"circle-stroke-width\": 1,\n                //   \"circle-radius\": 4,\n                //   \"circle-color\": \"#FFEB3B\"\n                    'circle-color': [\n                        'step',\n                        ['get', 'point_count'],\n                        '#ffb6ab',\n                        30,\n                        '#f5735f',\n                        75,\n                        '#b83e2c'\n                        ],\n                        'circle-radius': [\n                        'step',\n                        ['get', 'point_count'],\n                        20,\n                        30,\n                        30,\n                        75,\n                        40\n                    ]\n                },\n                layout: {\n                    // make layer visible by default\n                    'visibility': 'visible'\n                }\n            });\n\n            map.addLayer({\n                id: 'cluster-count',\n                // id: 'clusters',\n                type: 'symbol',\n                source: \"crime\", // this should be the id of the source\n                filter: ['has', 'point_count'],\n                layout: {\n                    'text-field': '{point_count_abbreviated}',\n                    'text-font': ['Arial Unicode MS Bold'],\n                    'text-size': 12,\n                    'visibility': 'visible'\n                }\n            });\n\n            map.addLayer({\n                id: 'unclustered-point',\n                // id: 'clusters',\n                type: 'circle',\n                source: \"crime\", // this should be the id of the source\n                filter: ['!', ['has', 'point_count']],\n                paint: {\n                    'circle-color': '#fc0b03',\n                    // 'circle-color': '#ffffff',\n                    'circle-radius': 4,\n                    'circle-stroke-width': 1,\n                    'circle-stroke-color': '#fff'\n                    },\n                layout: {\n                    // make layer visible by default\n                    'visibility': 'visible'\n                    }\n            });\n            \n            // testing routing api\n            {    \n            map.addSource('theRoute', {\n                type: 'geojson',\n                data: {\n                    type: 'Feature'\n                }\n            });\n                 \n            map.addLayer({\n                id: 'theRoute',\n                type: 'line',\n                source: 'theRoute',\n                layout: {\n                'line-join': 'round',\n                'line-cap': 'round'\n                },\n                paint: {\n                'line-color': '#4881c5',\n                'line-opacity': 0.75,\n                'line-width': 10,\n                'line-blur': 0.5,\n                }\n            });\n                 \n            // Source and layer for the bounding box\n            map.addSource('theBox', {\n                type: 'geojson',\n                data: {\n                type: 'Feature'\n                }\n                });\n                map.addLayer({\n                id: 'theBox',\n                type: 'fill',\n                source: 'theBox',\n                layout: {},\n                paint: {\n                'fill-color': '#FFC300',\n                'fill-opacity': 0.5,\n                'fill-outline-color': '#FFC300'\n                }\n            });\n            }\n        });\n\n        let cities = ['Boston', 'Fort Worth', 'Chicago', 'San Francisco'];\n        \n        let lng_lat_zoom = {\n            \"Boston\": {\n                center: [-71.0799, 42.3083],\n                zoom: 11.27\n            },\n            \"Fort Worth\": {\n                center: [-97.3444, 32.8168],\n                zoom: 9.73\n            },\n            \"Chicago\": {\n                center: [-87.72023,41.83138],\n                zoom: 10\n            },\n            \"San Francisco\": {\n                center: [-122.44779,37.76190],\n                zoom: 12\n            }\n        }\n        let data = {\n            \"Boston\": bos,\n            \"Fort Worth\": fw,\n            \"Chicago\": chi,\n            \"San Francisco\": sf,\n        }\n\n        // once map loads, populate menu bar\n        map.once('load', function() {\n            for (let i = 0; i < cities.length; i++) {\n                console.log(cities[i])        \n                let link = document.createElement('a');\n                link.id = cities[i];\n                link.href = '#';\n                link.className = 'active city_menu';\n                link.textContent = cities[i];\n                let layers = document.getElementById('menu');\n                layers.appendChild(link);\n            }\n            // fly to city, set obstacle \n            let menu_cities = document.getElementsByClassName(\"city_menu\");\n            for (let i = 0; i < menu_cities.length; i++) {\n                menu_cities[i].onclick = function(e) {\n                    map.flyTo(lng_lat_zoom[menu_cities[i].id])\n                    // obstacle = turf.buffer(data[cities[i].id], 7, { units: \"meters\" });\n                    current_city = data[menu_cities[i].id]\n                }\n                // map.getSource('obstacles').setData(obstacle);\n            }\n        })\n\n        // add navigation control (the +/- zoom buttons) the top right of the canvas\n        map.addControl(new mapboxgl.NavigationControl());\n\n        // add directions\n        const directions = new MapboxDirections({\n            accessToken: mapboxgl.accessToken,\n            unit: 'imperial',\n            profile: 'mapbox/walking',\n            geometries: 'geojson',\n            alternatives: false,\n            flyTo: false,\n            walkway_bias: .75,\n            alley_bias: -.75,\n            steps: true,\n            controls: { instructions: false },\n            flyTo: false\n        });\n\n        // add directions control with map\n        map.addControl(directions, 'top-left');\n\n        // check if obj is empty\n        let isEmpty = function(obj){\n            return Object.keys(obj).length === 0;\n        }\n\n        // hide an element\n        let hide_element = function(el_name) {\n            let el = document.getElementById(el_name);\n            el.style.visibility = \"hidden\";\n        }\n\n        // show an element\n        let show_element = function(el_name) {\n            let el = document.getElementById(el_name);\n            el.style.visibility = \"visible\";\n        }\n\n        // when directions clear, remove bbox, hide instructions and notice\n        directions.on('clear', function(e) {\n            counter = 0;\n            num_intersections = Infinity;\n            distance = Infinity;\n            map.setLayoutProperty('theBox', 'visibility', 'none');\n            let instructions = document.getElementById('instructions')\n            instructions.innerHTML = \"\"\n            instructions.style.visibility = \"hidden\"\n            hide_element(\"notice\");\n        });\n\n        let addDirections = function(route) {\n            directions.removeRoutes();\n            // let notice = document.getElementById(\"notice\");\n            // notice.style.visibility = \"hidden\"\n            hide_element(\"notice\")\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \"\n            let instructions = document.getElementById('instructions');\n            instructions.style.visibility = \"visible\"\n            let steps = route.legs[0].steps;\n            console.log(steps)\n            let total_dist = (route.distance / 1609.344).toFixed(2);\n            let duration = (route.duration / 60).toFixed(0);\n            let str = \"<tr> \"+ \"<td id=\\\"column1\\\"><b>\" + total_dist + \"mi\" + \"</b></td>\" + \"<td id=\\\"column2\\\">\" + duration + \"min\" + \"</td>\" + \"</tr>\"\n            instructions.innerHTML += str;\n            for (var i = 0; i < steps.length; i++) {                \n                let miles = (steps[i].distance / 1609.344).toFixed(2);\n                let dist = miles;\n                let unit = \"mi\";\n                let feet = (steps[i].distance / 0.3048).toFixed(0);\n                if (miles < 0.15) {\n                    dist = feet;\n                    unit = \"ft\"\n                }\n                // let str = \"<li> \"+steps[i].maneuver.instruction + \"--\" + dist + unit + \"</li>\"\n                let str = \"<tr> \"+ \"<td id=\\\"column1\\\">\" + dist + unit + \"</td>\" + \"<td id=\\\"column2\\\">\" + steps[i].maneuver.instruction + \"</td>\" + \"</tr>\"\n                instructions.innerHTML += str;\n            }\n        }\n\n        directions.on('route', function (e) {\n            // make sure city is selected\n            if (current_city == null) {\n                window.alert(\"Please select a city in the menu in the bottom left!\");\n                directions.removeRoutes();\n                return;\n            }\n            // corner case - stop routing if origin / dest is removed while calculating route\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) || isEmpty(tempd)) {\n                directions.removeRoutes();\n                return;\n            }\n            // show notice of which route is being calculated\n            let notice = document.getElementById(\"notice\");\n            if (notice.style.visibility != \"visible\") notice.style.visibility = \"visible\";\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \" + counter + \".\"\n            // if directions visible, hide\n            let instructions = document.getElementById('instructions');\n            if (instructions.style.visibility != \"hidden\") instructions.style.visibility = \"hidden\";\n            \n            let routes = e.route;\n             \n            if (counter >= maxAttempts) {\n                // set route on map, add directions\n                e.route = route;\n                map.getSource('theRoute').setData(min_intersections);\n                addDirections(e.route);\n            } \n            else {\n                routes.forEach((e) => {\n\n                    // make route and bbox visible\n                    map.setLayoutProperty('theRoute', 'visibility', 'visible');\n                    map.setLayoutProperty('theBox', 'visibility', 'visible');\n                    \n                    // get GeoJson LineString feature of route\n                    let routeLine = polyline.toGeoJSON(e.geometry);\n                    \n                    // create a bbox around this route\n                    bbox = turf.bbox(routeLine);\n                    polygon = turf.bboxPolygon(bbox);\n\n                    // get pts in the city that are in bbox, check num of isects\n                    let points_within = turf.pointsWithinPolygon(current_city, polygon);\n                    obstacle = turf.buffer(points_within, 7, { units: \"meters\" });\n                    let intersects = turf.lineIntersect(obstacle, routeLine);\n\n                    // get route with minimum isects\n                    if (intersects.features.length <= num_intersections) {\n                        // distance pruning\n                        if (intersects.features.length == num_intersections && e.distance < distance) {\n                            num_intersections = intersects.features.length;\n                            min_intersections = routeLine;\n                            distance = e.distance\n                            route = e;\n                        }\n                        else if (intersects.features.length < num_intersections) {\n                            num_intersections = intersects.features.length;\n                            min_intersections = routeLine;\n                            distance = e.distance\n                            route = e;\n                        }\n                    }\n                    \n                    // update route line and bbox\n                    map.getSource('theRoute').setData(routeLine);\n                    map.getSource('theBox').setData(polygon);\n                    \n                    // check if route isect w/ pts in bbox \n                    let clear = turf.booleanDisjoint(obstacle, routeLine);\n                    \n                    if (clear == true) {\n                        // Hide the box\n                        map.setLayoutProperty('theBox', 'visibility', 'none');\n                        // map.setPaintProperty('theRoute', 'line-color', '#74c476');\n                        // Reset the counter, min intersections, distance\n                        route = e;\n                        counter = 0;\n                        num_intersections = Infinity;\n                        distance = Infinity;\n                        addDirections(route);\n                    } else {\n                    // isect \n                        counter = counter + 1;\n                        // increase bbox by factor of counter\n                        polygon = turf.transformScale(polygon, counter * 0.025);\n                        bbox = turf.bbox(polygon);\n                        \n                        // add a random waypoint to get a route from the directions api\n                        let randomWaypoint = turf.randomPoint(1, { bbox: bbox });\n                        directions.setWaypoint(\n                            0,\n                            randomWaypoint['features'][0].geometry.coordinates\n                        );\n                    }\n                });\n            }\n        });\n\n        map.on('move', function() {\n            // shitty workaround\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) || isEmpty(tempd)) {\n                map.setLayoutProperty('theRoute', 'visibility', 'none');\n            }\n            setLng(map.getCenter().lng.toFixed(4));\n            setLat(map.getCenter().lat.toFixed(4));\n            setZoom(map.getZoom().toFixed(2));\n        });\n\n        // map.on('moveend', function() {\n        //     let lng = map.getCenter().lng.toFixed(4)\n        //     console.log(lng_city[lng])\n        //     if (lng_city[lng]) {\n        //         obstacle = turf.buffer(lng_city[lng], 7, { units: \"meters\" });\n        //         // map.getSource('obstacles').setData(obstacle);\n        //     }\n        // })\n        // let close_loader = document.getElementById(\"loader\");\n        let close_loader = document.getElementById(\"close\");\n        close_loader.onclick = function(e) {\n            close_loader.parentElement.style.visibility = \"hidden\";\n        }\n\n        let toggle_loader = document.getElementById(\"question\");\n        toggle_loader.onclick = function(e) {\n            if (close_loader.parentElement.style.visibility == \"hidden\")\n                close_loader.parentElement.style.visibility = \"visible\";\n            else\n                close_loader.parentElement.style.visibility = \"hidden\";\n        }\n\n        \n\n        // Clean up on unmount\n        return () => map.remove();\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return (\n        <div>\n            <nav id=\"menu\">\n                <a id=\"title\" href=\"#\">\n                    Available Cities\n                </a>\n            </nav>\n            \n            <div id=\"loader\">\n                <br/>\n                <h1>A New Way to Navigate</h1>\n                This is an application created to help you navigate around crime-ridden areas in dense urban areas. \n                <br/>\n                Current featured cities include Boston, Fort Worth, Chicago, and San Francisco.\n                <br/>\n                <br/>\n                Each red circle indicates a cluster of plotted crime data, with the number signaling the cluster size. Zoom in closer to get a better look.\n                <br/>\n                <br/>\n                Click on a city in the lower left menu to get started!\n                {/* <a id=\"close\">x</a> */}\n                <div id=\"close\">\n                <XIcon size={24}/>\n                </div>\n            </div>\n        <div id=\"notice\">\n           <b>Your custom route is being calculated!</b> \n           <br/>\n           <div id=\"route_num\">Running route </div>\n        </div>\n\n        \n        {/* <table id=\"distance_duration\" >\n        </table> */}\n        <div id=\"table\">\n        <table id=\"instructions\" >\n            {/* <tbody>\n            <tr>\n                <td id=\"column1\"><b>.21mi</b> </td>\n                <td id=\"column2\">10min</td>\n            </tr>\n            <tr>\n                <td id=\"column1\">209ft</td>\n                <td id=\"column2\">Walk northeast on Puritan Avenue.</td>\n            </tr>\n            </tbody> */}\n        </table>\n        </div>\n        \n        {/* <div className='sidebarStyle'>\n            <div>\n            Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n            </div>\n        </div> */}\n        <div id=\"question\">\n            <QuestionIcon size={24} fill=\"#FFFFFF\"/>\n        </div>\n        <div className='map-container' ref={mapContainerRef} />\n        \n        </div>\n    );\n};\n\nexport default App;\n\n// class App extends React.Component {\n\n//   componentDidMount() {\n\n//     // Creates new map instance\n//     const map = new mapboxgl.Map({\n//       container: this.mapWrapper,\n//       style: 'mapbox://styles/mapbox/streets-v10',\n//       center: [-73.985664, 40.748514],\n//       zoom: 12\n//     });\n\n//     // Creates new directions control instance\n//     const directions = new MapboxDirections({\n//       accessToken: mapboxgl.accessToken,\n//       unit: 'metric',\n//       profile: 'mapbox/driving',\n//     });\n\n//     // Integrates directions control with map\n//     map.addControl(directions, 'top-left');\n//   }\n\n//   render() {\n//     return (\n//       // Populates map by referencing map's container property\n//       <div ref={el => (this.mapWrapper = el)} className=\"mapWrapper\" />\n//     );\n//   }\n// }\n\n// export default App;\n\n                // turns off cities\n                // link.onclick = function (e) {\n                //     for (let index in dictionary[key]) {\n                //         let clickedLayer = dictionary[key][index];\n                //         e.preventDefault();\n                //         e.stopPropagation();\n                    \n                //         let visibility = map.getLayoutProperty(clickedLayer, 'visibility');\n                    \n                //         if (visibility === 'visible') {\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'none');\n                //             this.className = '';\n                //         } else {\n                //             this.className = 'active';\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'visible');\n                //         }\n                //     }\n                // };","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}