{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapboxgl","accessToken","App","mapContainerRef","useRef","useState","lng","setLng","lat","setLat","zoom","setZoom","useEffect","min_intersections","current_city","route","map","Map","container","current","style","center","obstacle","turf","fw","units","bbox","polygon","counter","num_intersections","Infinity","on","cities","data","bos","chi","sf","i","length","addSource","type","cluster","clusterMaxZoom","clusterRadius","addLayer","id","source","filter","paint","layout","dictionary","lng_lat_zoom","once","key","hasOwnProperty","console","log","link","document","createElement","href","className","textContent","getElementById","appendChild","getElementsByClassName","onclick","e","flyTo","addControl","NavigationControl","directions","MapboxDirections","unit","profile","geometries","alternatives","walkway_bias","alley_bias","steps","controls","instructions","isEmpty","obj","Object","keys","setLayoutProperty","innerHTML","visibility","addDirections","removeRoutes","legs","str","distance","toFixed","duration","maneuver","instruction","miles","dist","feet","tempo","getOrigin","tempd","getDestination","notice","routes","getSource","setData","forEach","routeLine","polyline","toGeoJSON","geometry","points_within","intersects","features","randomWaypoint","setWaypoint","coordinates","getCenter","getZoom","remove","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d5394972.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport './App.css';\nimport mapboxgl from 'mapbox-gl';\n// import 'mapbox-gl/dist/mapbox-gl.css';\nimport MapboxDirections from '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions'\nimport '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'\nimport * as turf from '@turf/turf';\nimport polyline from '@mapbox/polyline'\nimport bos from './bos_nodupes.json'\nimport fw from './fw_nodupes.json'\nimport chi from './chi_nodupes.json'\nimport sf from './sf_nodupes.json'\n\nmapboxgl.accessToken =\n    'pk.eyJ1IjoiYW5hYmVsbGVjaGFuZyIsImEiOiJja20xZmVxNGYwMTRpMnJtemJ0M3podzFzIn0.punpaEzFpzG4kmbcpdtwUQ'\n\nconst App = () => {\n    // playign with here api\n    {\n    // const apiUrl = 'https://route.ls.hereapi.com/routing/7.2/calculateroute.json?apiKey=dQsyJbZZS_IvjJSlSFFxt1tadvGuxoOzkxEn5wGTP80&waypoint0=geo!52.5184443440238,13.383906494396967&waypoint1=geo!52.51435421904425,13.396947378094524&mode=fastest;car;traffic:disabled&avoidareas=52.517100760,13.3905424488;52.5169701849,13.391808451!52.51623131288022,13.389888672738778;52.51335487996589,13.395274548440511!52.52006148651319,13.385160024545286;52.517760038213815,13.389707563495335';\n    // fetch(apiUrl)\n    //   .then((response) => response.json())\n    //   .then((data) => console.log('This is your data', data));\n    }\n      \n    const mapContainerRef = useRef(null);\n    // boston\n    // const [lng, setLng] = useState(-71.0799);\n    // const [lat, setLat] = useState(42.3083);\n    // const [zoom, setZoom] = useState(13.59);\n\n    const [lng, setLng] = useState(-96.2485);\n    const [lat, setLat] = useState(38.5370);\n    const [zoom, setZoom] = useState(4.16);\n    // Initialize map when component mounts\n    useEffect(() => {\n        // crate new map\n        const map = new mapboxgl.Map({\n        container: mapContainerRef.current,\n        style: 'mapbox://styles/mapbox/dark-v10',\n        //   style: 'mapbox://styles/anabellechang/ckm11howb889h17qf87wj3ld6',\n        center: [lng, lat],\n        zoom: zoom\n        });\n\n        let obstacle = turf.buffer(fw, 7, { units: \"meters\" });\n        let bbox = [0, 0, 0, 0];\n        let polygon = turf.bboxPolygon(bbox);\n        let counter = 0;\n        let maxAttempts = 50;\n        let min_intersections;\n        let num_intersections = Infinity;\n        let current_city;\n        let route;\n\n        map.on('load', function() {\n            let cities = ['bos', 'fw', 'chi', 'sf'];\n            let data = [bos, fw, chi, sf]\n            \n            for (let i = 0; i < cities.length; i++) {\n                map.addSource(\"crime-\" + cities[i], {\n                    type: 'geojson',\n                    // data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'\n                    data: data[i],\n                    cluster: true,\n                    clusterMaxZoom: 14,\n                    clusterRadius: 50\n                });\n\n                map.addLayer({\n                    id: \"clusters-\" + cities[i],\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    type: \"circle\",\n                    filter: ['has', 'point_count'],\n                    // paint properties\n                    paint: {\n                    //   \"circle-opacity\": 0.75,\n                    //   \"circle-stroke-width\": 1,\n                    //   \"circle-radius\": 4,\n                    //   \"circle-color\": \"#FFEB3B\"\n                        'circle-color': [\n                            'step',\n                            ['get', 'point_count'],\n                            '#ffb6ab',\n                            30,\n                            '#f5735f',\n                            75,\n                            '#b83e2c'\n                            ],\n                            'circle-radius': [\n                            'step',\n                            ['get', 'point_count'],\n                            20,\n                            30,\n                            30,\n                            75,\n                            40\n                        ]\n                    },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'cluster-count-' + cities[i],\n                    // id: 'clusters',\n                    type: 'symbol',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['has', 'point_count'],\n                    layout: {\n                        'text-field': '{point_count_abbreviated}',\n                        'text-font': ['Arial Unicode MS Bold'],\n                        'text-size': 12,\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'unclustered-point-' + cities[i],\n                    // id: 'clusters',\n                    type: 'circle',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['!', ['has', 'point_count']],\n                    paint: {\n                        'circle-color': '#fc0b03',\n                        // 'circle-color': '#ffffff',\n                        'circle-radius': 4,\n                        'circle-stroke-width': 1,\n                        'circle-stroke-color': '#fff'\n                        },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                        }\n                });\n                // console.log(map.getStyle().layers)\n            }\n            // testing routing api\n            {\n            \n            // map.addSource(\"obstacles\", {\n            //     type: 'geojson',\n            //     data: obstacle\n            // })\n            // map.addLayer({\n            //     id: 'obstacles',\n            //     type: 'fill',\n            //     source: \"obstacles\",\n            //     paint: {\n            //         'fill-color': '#f03b20',\n            //         // 'circle-radius': 5,\n            //         // 'circle-stroke-width': 1,\n            //         'fill-opacity': 0.5,\n            //         'fill-outline-color': '#f03b20'\n            //     }\n            // });\n                 \n            map.addSource('theRoute', {\n                type: 'geojson',\n                data: {\n                    type: 'Feature'\n                }\n            });\n                 \n            map.addLayer({\n                id: 'theRoute',\n                type: 'line',\n                source: 'theRoute',\n                layout: {\n                'line-join': 'round',\n                'line-cap': 'round'\n                },\n                paint: {\n                'line-color': '#4881c5',\n                'line-opacity': 0.75,\n                'line-width': 10,\n                'line-blur': 0.5,\n                }\n            });\n                 \n            // Source and layer for the bounding box\n            map.addSource('theBox', {\n                type: 'geojson',\n                data: {\n                type: 'Feature'\n                }\n                });\n                map.addLayer({\n                id: 'theBox',\n                type: 'fill',\n                source: 'theBox',\n                layout: {},\n                paint: {\n                'fill-color': '#FFC300',\n                'fill-opacity': 0.5,\n                'fill-outline-color': '#FFC300'\n                }\n            });\n            }\n        });\n\n        let dictionary = {\n            \"Boston\": ['clusters-bos', 'cluster-count-bos', 'unclustered-point-bos'],\n            \"Fort Worth\": ['clusters-fw', 'cluster-count-fw', 'unclustered-point-fw'],\n            \"Chicago\": ['clusters-chi', 'cluster-count-chi', 'unclustered-point-chi'],\n            \"San Francisco\": ['clusters-sf', 'cluster-count-sf', 'unclustered-point-sf'],\n        }\n        let lng_lat_zoom = {\n            \"Boston\": {\n                center: [-71.0799, 42.3083],\n                zoom: 11.27\n            },\n            \"Fort Worth\": {\n                center: [-97.3444, 32.8168],\n                zoom: 9.73\n            },\n            \"Chicago\": {\n                center: [-87.72023,41.83138],\n                zoom: 10\n            },\n            \"San Francisco\": {\n                center: [-122.44779,37.76190],\n                zoom: 10\n            }\n        }\n        let data = {\n            \"Boston\": bos,\n            \"Fort Worth\": fw,\n            \"Chicago\": chi,\n            \"San Francisco\": sf,\n        }\n\n        map.once('load', function() {\n            for (let key in dictionary) {\n                // check if the property/key is defined in the object itself, not in parent\n                if (dictionary.hasOwnProperty(key)) {           \n                    console.log(key, dictionary[key]);\n                    let link = document.createElement('a');\n                    link.id = key;\n                    link.href = '#';\n                    link.className = 'active city_menu';\n                    link.textContent = key;\n                let layers = document.getElementById('menu');\n                layers.appendChild(link);\n                }\n            }\n            // fly to city, set obstacle \n            let cities = document.getElementsByClassName(\"city_menu\");\n            for (let i = 0; i < cities.length; i++) {\n                cities[i].onclick = function(e) {\n                    map.flyTo(lng_lat_zoom[cities[i].id])\n                    // obstacle = turf.buffer(data[cities[i].id], 7, { units: \"meters\" });\n                    current_city = data[cities[i].id]\n                }\n                // map.getSource('obstacles').setData(obstacle);\n            }\n        })\n\n        // Add navigation control (the +/- zoom buttons) the top right of the canvas\n        map.addControl(new mapboxgl.NavigationControl());\n        // map.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n        const directions = new MapboxDirections({\n            accessToken: mapboxgl.accessToken,\n            unit: 'imperial',\n            profile: 'mapbox/walking',\n            geometries: 'geojson',\n            alternatives: false,\n            flyTo: false,\n            walkway_bias: .75,\n            alley_bias: -.75,\n            steps: true,\n            controls: { instructions: false },\n            flyTo: false\n        });\n\n        // Integrates directions control with map\n        map.addControl(directions, 'top-left');\n\n        let isEmpty = function(obj){\n            return Object.keys(obj).length === 0;\n        }\n\n        directions.on('clear', function(e) {\n            counter = 0;\n            num_intersections = Infinity;\n            // map.setLayoutProperty('theRoute', 'visibility', 'none');\n            map.setLayoutProperty('theBox', 'visibility', 'none');\n            let instructions = document.getElementById('instructions')\n            instructions.innerHTML = \"\"\n            instructions.style.visibility = \"hidden\"\n        });\n\n        let addDirections = function(route) {\n            directions.removeRoutes();\n            let notice = document.getElementById(\"notice\");\n            notice.style.visibility = \"hidden\"\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \"\n            let instructions = document.getElementById('instructions');\n            instructions.style.visibility = \"visible\"\n            let steps = route.legs[0].steps;\n            console.log(steps)\n            let total_dist = (route.distance / 1609.344).toFixed(2);\n            let duration = (route.duration / 60).toFixed(0);\n            let str = \"<tr> \"+ \"<td id=\\\"column1\\\"><b>\" + total_dist + \"mi\" + \"</b></td>\" + \"<td id=\\\"column2\\\">\" + duration + \"min\" + \"</td>\" + \"</tr>\"\n            instructions.innerHTML += str;\n            for (var i = 0; i < steps.length; i++) {\n                console.log(steps[i].maneuver.instruction);\n                \n                let miles = (steps[i].distance / 1609.344).toFixed(2);\n                let dist = miles;\n                let unit = \"mi\";\n                let feet = (steps[i].distance / 0.3048).toFixed(0);\n                if (miles < 0.15) {\n                    dist = feet;\n                    unit = \"ft\"\n                }\n                // let str = \"<li> \"+steps[i].maneuver.instruction + \"--\" + dist + unit + \"</li>\"\n                let str = \"<tr> \"+ \"<td id=\\\"column1\\\">\" + dist + unit + \"</td>\" + \"<td id=\\\"column2\\\">\" + steps[i].maneuver.instruction + \"</td>\" + \"</tr>\"\n                instructions.innerHTML += str;\n            }\n        }\n\n        directions.on('route', function (e) {\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) || isEmpty(tempd)) {\n                directions.removeRoutes();\n                return;\n            }\n            let notice = document.getElementById(\"notice\");\n            if (notice.style.visibility != \"visible\") notice.style.visibility = \"visible\";\n            let route_num = document.getElementById(\"route_num\");\n            route_num.innerHTML = \"Running route \" + counter + \".\"\n\n            let instructions = document.getElementById('instructions');\n            if (instructions.style.visibility != \"hidden\") instructions.style.visibility = \"hidden\";\n            \n            let routes = e.route;\n             \n            // Hide the route and box by setting the opacity to zero\n            // map.setLayoutProperty('theRoute', 'visibility', 'none');\n            // map.setLayoutProperty('theBox', 'visibility', 'none');\n             \n            if (counter >= maxAttempts) {\n                console.log(min_intersections)\n                e.route = route;\n                console.log(e.route)\n                map.getSource('theRoute').setData(min_intersections);\n                addDirections(e.route);\n            } \n            else {\n                // Make each route visible\n                routes.forEach((e) => {\n\n                    console.log(counter);\n                    // Make each route visible\n                    map.setLayoutProperty('theRoute', 'visibility', 'visible');\n                    map.setLayoutProperty('theBox', 'visibility', 'visible');\n                    \n                    // Get GeoJson LineString feature of route\n                    let routeLine = polyline.toGeoJSON(e.geometry);\n                    \n                    // Create a bounding box around this route\n                    // The app will find a random point in the new bbox\n                    bbox = turf.bbox(routeLine);\n                    polygon = turf.bboxPolygon(bbox);\n                    let points_within = turf.pointsWithinPolygon(current_city, polygon);\n                    obstacle = turf.buffer(points_within, 7, { units: \"meters\" });\n                    let intersects = turf.lineIntersect(obstacle, routeLine);\n\n                    // get route with minimum intersections\n                    if (intersects.features.length < num_intersections) {\n                        num_intersections = intersects.features.length;\n                        min_intersections = routeLine;\n                        route = e;\n                    }\n                    \n                    // // Create a bounding box around this route\n                    // // The app will find a random point in the new bbox\n                    // bbox = turf.bbox(routeLine);\n                    // polygon = turf.bboxPolygon(bbox);\n                    // let points_within = turf.pointsWithinPolygon(bos, polygon);\n                    // console.log(points_within)\n                    \n                    // Update the data for the route\n                    // This will update the route line on the map\n                    map.getSource('theRoute').setData(routeLine);\n                    // Update the box\n                    map.getSource('theBox').setData(polygon);\n                    \n                    let clear = turf.booleanDisjoint(obstacle, routeLine);\n                    \n                    if (clear == true) {\n                        // Hide the box\n                        map.setLayoutProperty('theBox', 'visibility', 'none');\n                        // map.setPaintProperty('theRoute', 'line-color', '#74c476');\n                        // Reset the counter, min intersections\n                        route = e;\n                        counter = 0;\n                        num_intersections = Infinity;\n                        addDirections(route);\n                    } else {\n                    // Collision occurred, so increment the counter\n                        counter = counter + 1;\n                        // As the attempts increase, expand the search area\n                        // by a factor of the attempt count\n                        polygon = turf.transformScale(polygon, counter * 0.025);\n                        bbox = turf.bbox(polygon);\n                        // map.setPaintProperty('theRoute', 'line-color', '#4881c5');\n                        \n                        // Add a randomly selected waypoint to get a new route from the Directions API\n                        let randomWaypoint = turf.randomPoint(1, { bbox: bbox });\n                        directions.setWaypoint(\n                            0,\n                            randomWaypoint['features'][0].geometry.coordinates\n                        );\n                    }\n                });\n            }\n        });\n\n        map.on('move', function() {\n            // shitty workaround\n            let tempo = directions.getOrigin();\n            let tempd = directions.getDestination();\n            if (isEmpty(tempo) || isEmpty(tempd)) {\n                map.setLayoutProperty('theRoute', 'visibility', 'none');\n            }\n            setLng(map.getCenter().lng.toFixed(4));\n            setLat(map.getCenter().lat.toFixed(4));\n            setZoom(map.getZoom().toFixed(2));\n        });\n\n        // map.on('moveend', function() {\n        //     let lng = map.getCenter().lng.toFixed(4)\n        //     console.log(lng_city[lng])\n        //     if (lng_city[lng]) {\n        //         obstacle = turf.buffer(lng_city[lng], 7, { units: \"meters\" });\n        //         // map.getSource('obstacles').setData(obstacle);\n        //     }\n        // })\n\n        \n\n        // Clean up on unmount\n        return () => map.remove();\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return (\n        <div>\n            <nav id=\"menu\">\n                <a id=\"title\" href=\"#\">\n                    Available Cities\n                </a>\n            </nav>\n            \n            <div id=\"loader\">\n                <br/>\n                <h1>Welcome to Crime Navigation!</h1>\n                This is an application created to help you navigate around crime-ridden areas in dense urban areas. Current featured cities include Boston and Fort Worth.\n                <br/>\n                <br/>\n                Click on a city in the lower left menu to get started!\n                <a id=\"x\">x</a>\n            </div>\n        <div id=\"notice\">\n           <b>Your custom route is being calculated!</b> \n           <br/>\n           <div id=\"route_num\">Running route </div>\n        </div>\n\n        \n        {/* <table id=\"distance_duration\" >\n        </table> */}\n        <div id=\"table\">\n        <table id=\"instructions\" >\n            {/* <tbody>\n            <tr>\n                <td id=\"column1\"><b>.21mi</b> </td>\n                <td id=\"column2\">10min</td>\n            </tr>\n            <tr>\n                <td id=\"column1\">209ft</td>\n                <td id=\"column2\">Walk northeast on Puritan Avenue.</td>\n            </tr>\n            </tbody> */}\n        </table>\n        </div>\n        \n        {/* <div className='sidebarStyle'>\n            <div>\n            Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n            </div>\n        </div> */}\n        <div className='map-container' ref={mapContainerRef} />\n        \n        </div>\n    );\n};\n\nexport default App;\n\n// class App extends React.Component {\n\n//   componentDidMount() {\n\n//     // Creates new map instance\n//     const map = new mapboxgl.Map({\n//       container: this.mapWrapper,\n//       style: 'mapbox://styles/mapbox/streets-v10',\n//       center: [-73.985664, 40.748514],\n//       zoom: 12\n//     });\n\n//     // Creates new directions control instance\n//     const directions = new MapboxDirections({\n//       accessToken: mapboxgl.accessToken,\n//       unit: 'metric',\n//       profile: 'mapbox/driving',\n//     });\n\n//     // Integrates directions control with map\n//     map.addControl(directions, 'top-left');\n//   }\n\n//   render() {\n//     return (\n//       // Populates map by referencing map's container property\n//       <div ref={el => (this.mapWrapper = el)} className=\"mapWrapper\" />\n//     );\n//   }\n// }\n\n// export default App;\n\n                // turns off cities\n                // link.onclick = function (e) {\n                //     for (let index in dictionary[key]) {\n                //         let clickedLayer = dictionary[key][index];\n                //         e.preventDefault();\n                //         e.stopPropagation();\n                    \n                //         let visibility = map.getLayoutProperty(clickedLayer, 'visibility');\n                    \n                //         if (visibility === 'visible') {\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'none');\n                //             this.className = '';\n                //         } else {\n                //             this.className = 'active';\n                //             map.setLayoutProperty(clickedLayer, 'visibility', 'visible');\n                //         }\n                //     }\n                // };","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}