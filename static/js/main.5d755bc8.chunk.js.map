{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapboxgl","accessToken","App","mapContainerRef","useRef","useState","lng","setLng","lat","setLat","zoom","setZoom","useEffect","map","Map","container","current","style","center","on","cities","cities_geo","i","length","addSource","type","data","cluster","clusterMaxZoom","clusterRadius","addLayer","id","source","filter","paint","layout","obstacle","turf","fw","units","console","log","bbox","polygon","counter","addControl","NavigationControl","directions","MapboxDirections","unit","profile","geometries","alternatives","controls","instructions","flyTo","e","document","getElementById","routes","route","setLayoutProperty","forEach","routeLine","polyline","toGeoJSON","geometry","intersects","getSource","setData","setPaintProperty","randomWaypoint","setWaypoint","coordinates","getCenter","toFixed","getZoom","dictionary","key","hasOwnProperty","link","createElement","href","className","textContent","onclick","index","clickedLayer","preventDefault","stopPropagation","getLayoutProperty","this","appendChild","remove","ref","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5d755bc8.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport './App.css';\nimport mapboxgl from 'mapbox-gl';\n// import 'mapbox-gl/dist/mapbox-gl.css';\nimport MapboxDirections from '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions'\nimport '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'\nimport * as turf from '@turf/turf';\nimport polyline from '@mapbox/polyline'\nimport bos from './bos_final.json'\nimport fw from './fw_final.json'\n\nmapboxgl.accessToken =\n    'pk.eyJ1IjoiYW5hYmVsbGVjaGFuZyIsImEiOiJja20xZmVxNGYwMTRpMnJtemJ0M3podzFzIn0.punpaEzFpzG4kmbcpdtwUQ'\n\nconst App = () => {\n    // playign with here api\n    {\n    // const apiUrl = 'https://route.ls.hereapi.com/routing/7.2/calculateroute.json?apiKey=dQsyJbZZS_IvjJSlSFFxt1tadvGuxoOzkxEn5wGTP80&waypoint0=geo!52.5184443440238,13.383906494396967&waypoint1=geo!52.51435421904425,13.396947378094524&mode=fastest;car;traffic:disabled&avoidareas=52.517100760,13.3905424488;52.5169701849,13.391808451!52.51623131288022,13.389888672738778;52.51335487996589,13.395274548440511!52.52006148651319,13.385160024545286;52.517760038213815,13.389707563495335';\n    // fetch(apiUrl)\n    //   .then((response) => response.json())\n    //   .then((data) => console.log('This is your data', data));\n    }\n      \n    const mapContainerRef = useRef(null);\n\n    const [lng, setLng] = useState(-71.0799);\n    const [lat, setLat] = useState(42.3083)\n    const [zoom, setZoom] = useState(13.59);\n\n    // Initialize map when component mounts\n    useEffect(() => {\n        // crate new map\n        const map = new mapboxgl.Map({\n        container: mapContainerRef.current,\n        style: 'mapbox://styles/mapbox/streets-v11',\n        //   style: 'mapbox://styles/anabellechang/ckm11howb889h17qf87wj3ld6',\n        center: [lng, lat],\n        zoom: zoom\n        });\n\n        map.on('load', function() {\n            let cities = ['bos', 'fw'];\n            let cities_geo = ['https://raw.githubusercontent.com/belle-chang/navi-crime/main/data/jsonformatter-2.json', 'https://raw.githubusercontent.com/belle-chang/crime-navi/main/data/fw_final.json'];\n\n            for (let i = 0; i < cities.length; i++) {\n                map.addSource(\"crime-\" + cities[i], {\n                    type: 'geojson',\n                    // data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'\n                    data: cities_geo[i],\n                    cluster: true,\n                    clusterMaxZoom: 14,\n                    clusterRadius: 50\n                });\n\n                map.addLayer({\n                    id: \"clusters-\" + cities[i],\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    type: \"circle\",\n                    filter: ['has', 'point_count'],\n                    // paint properties\n                    paint: {\n                    //   \"circle-opacity\": 0.75,\n                    //   \"circle-stroke-width\": 1,\n                    //   \"circle-radius\": 4,\n                    //   \"circle-color\": \"#FFEB3B\"\n                        'circle-color': [\n                            'step',\n                            ['get', 'point_count'],\n                            '#ffb6ab',\n                            20,\n                            '#f5735f',\n                            50,\n                            '#b83e2c'\n                            ],\n                            'circle-radius': [\n                            'step',\n                            ['get', 'point_count'],\n                            20,\n                            20,\n                            30,\n                            50,\n                            40\n                        ]\n                    },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'cluster-count-' + cities[i],\n                    // id: 'clusters',\n                    type: 'symbol',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['has', 'point_count'],\n                    layout: {\n                        'text-field': '{point_count_abbreviated}',\n                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],\n                        'text-size': 12,\n                        'visibility': 'visible'\n                    }\n                });\n    \n                map.addLayer({\n                    id: 'unclustered-point-' + cities[i],\n                    // id: 'clusters',\n                    type: 'circle',\n                    source: \"crime-\" + cities[i], // this should be the id of the source\n                    filter: ['!', ['has', 'point_count']],\n                    paint: {\n                        'circle-color': '#11b4da',\n                        'circle-radius': 4,\n                        'circle-stroke-width': 1,\n                        'circle-stroke-color': '#fff'\n                        },\n                    layout: {\n                        // make layer visible by default\n                        'visibility': 'visible'\n                        }\n                });\n                // console.log(map.getStyle().layers)\n            }\n            // testing routing api\n            {\n            map.addLayer({\n                id: 'clearances',\n                type: 'fill',\n                source: {\n                type: 'geojson',\n                data: obstacle\n                },\n                layout: {},\n                paint: {\n                'fill-color': '#f03b20',\n                // 'circle-radius': 5,\n                // 'circle-stroke-width': 1,\n                'fill-opacity': 0.5,\n                'fill-outline-color': '#f03b20'\n                }\n                });\n                 \n                map.addSource('theRoute', {\n                type: 'geojson',\n                data: {\n                type: 'Feature'\n                }\n                });\n                 \n                map.addLayer({\n                id: 'theRoute',\n                type: 'line',\n                source: 'theRoute',\n                layout: {\n                'line-join': 'round',\n                'line-cap': 'round'\n                },\n                paint: {\n                'line-color': '#cccccc',\n                'line-opacity': 0.5,\n                'line-width': 13,\n                'line-blur': 0.5\n                }\n                });\n                 \n                // Source and layer for the bounding box\n                map.addSource('theBox', {\n                type: 'geojson',\n                data: {\n                type: 'Feature'\n                }\n                });\n                map.addLayer({\n                id: 'theBox',\n                type: 'fill',\n                source: 'theBox',\n                layout: {},\n                paint: {\n                'fill-color': '#FFC300',\n                'fill-opacity': 0.5,\n                'fill-outline-color': '#FFC300'\n                }\n                });\n            }\n        });\n         // playing with turf\n         let clearances = {\n            type: \"FeatureCollection\",\n            features: [\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.47426, 38.06673],\n                },\n                properties: {\n                  clearance: \"13' 2\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.47208, 38.06694],\n                },\n                properties: {\n                  clearance: \"13' 7\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.60485, 38.12184],\n                },\n                properties: {\n                  clearance: \"13' 7\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.61905, 37.87504],\n                },\n                properties: {\n                  clearance: \"12' 0\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.55946, 38.30213],\n                },\n                properties: {\n                  clearance: \"13' 6\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.27235, 38.04954],\n                },\n                properties: {\n                  clearance: \"13' 6\",\n                },\n              },\n              {\n                type: \"Feature\",\n                geometry: {\n                  type: \"Point\",\n                  coordinates: [-84.27264, 37.82917],\n                },\n                properties: {\n                  clearance: \"11' 6\",\n                },\n              }\n            ]\n          };\n        let obstacle = turf.buffer(fw, 2.5, { units: \"meters\" });\n        console.log(obstacle)\n        let bbox = [0, 0, 0, 0];\n        let polygon = turf.bboxPolygon(bbox);\n        let counter = 0;\n        let maxAttempts = 50;\n        let emoji = '';\n        let collision = '';\n\n        // Add navigation control (the +/- zoom buttons) the top right of the canvas\n        map.addControl(new mapboxgl.NavigationControl());\n        // map.addControl(new mapboxgl.NavigationControl(), 'top-right');\n\n        const directions = new MapboxDirections({\n            accessToken: mapboxgl.accessToken,\n            unit: 'metric',\n            profile: 'mapbox/walking',\n            geometries: 'geojson',\n            alternatives: false,\n            controls: {instructions: false},\n            flyTo: false\n        });\n\n        // Integrates directions control with map\n        map.addControl(directions, 'top-left');\n\n        directions.on('clear', function(e) {\n            counter = 0;\n        })\n\n        directions.on('route', function (e) {\n            let reports = document.getElementById('reports');\n            let routes = e.route;\n             \n            // Hide the route and box by setting the opacity to zero\n            map.setLayoutProperty('theRoute', 'visibility', 'none');\n            map.setLayoutProperty('theBox', 'visibility', 'none');\n             \n            if (counter >= maxAttempts) {\n                console.log(\"no routes\")\n            } \n            else {\n                // Make each route visible\n                routes.forEach((e) => {\n                    // Make each route visible\n                    map.setLayoutProperty('theRoute', 'visibility', 'visible');\n                    map.setLayoutProperty('theBox', 'visibility', 'visible');\n                    \n                    // Get GeoJson LineString feature of route\n                    let routeLine = polyline.toGeoJSON(e.geometry);\n                    let intersects = turf.lineIntersect(obstacle, routeLine);\n                    console.log(\"intersects\")\n                    console.log(intersects)\n                    \n                    // Create a bounding box around this route\n                    // The app will find a random point in the new bbox\n                    bbox = turf.bbox(routeLine);\n                    polygon = turf.bboxPolygon(bbox);\n                    \n                    // Update the data for the route\n                    // This will update the route line on the map\n                    map.getSource('theRoute').setData(routeLine);\n                    \n                    // Update the box\n                    map.getSource('theBox').setData(polygon);\n                    \n                    let clear = turf.booleanDisjoint(obstacle, routeLine);\n                    \n                    if (clear == true) {\n                    collision = 'does not intersect any obstacles!';\n                    emoji = '✔️';\n                    map.setPaintProperty('theRoute', 'line-color', '#74c476');\n                    // Hide the box\n                    map.setLayoutProperty('theBox', 'visibility', 'none');\n                    // Reset the counter\n                    counter = 0;\n                    } else {\n                    // Collision occurred, so increment the counter\n                    counter = counter + 1;\n                    // As the attempts increase, expand the search area\n                    // by a factor of the attempt count\n                    polygon = turf.transformScale(polygon, counter * 0.01);\n                    bbox = turf.bbox(polygon);\n                    collision = 'is bad.';\n                    // detail = 'takes ' + (e.duration / 60).toFixed(0) + ' minutes and hits';\n                    emoji = '⚠️';\n                    map.setPaintProperty('theRoute', 'line-color', '#de2d26');\n                    \n                    // Add a randomly selected waypoint to get a new route from the Directions API\n                    let randomWaypoint = turf.randomPoint(1, { bbox: bbox });\n                    directions.setWaypoint(\n                        0,\n                        randomWaypoint['features'][0].geometry.coordinates\n                        );\n                    }\n                });\n            }\n        });\n\n        map.on('move', function() {\n            setLng(map.getCenter().lng.toFixed(4));\n            setLat(map.getCenter().lat.toFixed(4));\n            setZoom(map.getZoom().toFixed(2));\n        });\n\n        // CHANGE: Add layer names that need to be toggled\n        let dictionary = {\n            \"Boston\": ['clusters-bos', 'cluster-count-bos', 'unclustered-point-bos'],\n            \"Fort Worth\": ['clusters-fw', 'cluster-count-fw', 'unclustered-point-fw']\n        }\n\n        for (let key in dictionary) {\n            // check if the property/key is defined in the object itself, not in parent\n            if (dictionary.hasOwnProperty(key)) {           \n                console.log(key, dictionary[key]);\n\n                let link = document.createElement('a');\n                link.href = '#';\n                link.className = 'active';\n                link.textContent = key;\n                link.onclick = function (e) {\n                    \n                    for (let index in dictionary[key]) {\n                    let clickedLayer = dictionary[key][index];\n                    e.preventDefault();\n                    e.stopPropagation();\n                \n                    let visibility = map.getLayoutProperty(clickedLayer, 'visibility');\n                \n                    if (visibility === 'visible') {\n                        map.setLayoutProperty(clickedLayer, 'visibility', 'none');\n                        this.className = '';\n                    } else {\n                        this.className = 'active';\n                        map.setLayoutProperty(clickedLayer, 'visibility', 'visible');\n                    }\n                }\n                \n            };\n            let layers = document.getElementById('menu');\n            layers.appendChild(link);\n            }\n        }\n        \n\n        // Clean up on unmount\n        return () => map.remove();\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return (\n        <div>\n            <nav id=\"menu\">\n                <a id=\"title\" href=\"#\">\n                    Available Cities\n                </a>\n            </nav>\n        <div className='sidebarStyle'>\n            {/* <div>\n            Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n            </div> */}\n        </div>\n        <div className='map-container' ref={mapContainerRef} />\n        \n        </div>\n    );\n};\n\nexport default App;\n\n// class App extends React.Component {\n\n//   componentDidMount() {\n\n//     // Creates new map instance\n//     const map = new mapboxgl.Map({\n//       container: this.mapWrapper,\n//       style: 'mapbox://styles/mapbox/streets-v10',\n//       center: [-73.985664, 40.748514],\n//       zoom: 12\n//     });\n\n//     // Creates new directions control instance\n//     const directions = new MapboxDirections({\n//       accessToken: mapboxgl.accessToken,\n//       unit: 'metric',\n//       profile: 'mapbox/driving',\n//     });\n\n//     // Integrates directions control with map\n//     map.addControl(directions, 'top-left');\n//   }\n\n//   render() {\n//     return (\n//       // Populates map by referencing map's container property\n//       <div ref={el => (this.mapWrapper = el)} className=\"mapWrapper\" />\n//     );\n//   }\n// }\n\n// export default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}